---
title: Rust Integration
description: "Using img-src with Rust applications"
---

# Rust Integration

This guide shows how to integrate img-src into your Rust applications.

## Basic Usage

Use the SDK for type-safe API access:

```rust
use img_src::apis::{configuration::Configuration, images_api};
use std::path::PathBuf;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut config = Configuration::new();
    config.bearer_access_token = Some(
        std::env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
    );

    // Upload an image
    let res = images_api::upload_image(
        &config,
        Some(PathBuf::from("photo.jpg")),
        Some("photos/vacation.jpg"),
        None,
    ).await?;

    println!("Uploaded: {}", res.url);
    Ok(())
}
```

## URL Builder Helper

Create a helper for building transformation URLs:

```rust
pub struct TransformOptions {
    pub width: Option<u32>,
    pub height: Option<u32>,
    pub fit: Option<String>,
    pub quality: Option<u8>,
    pub preset: Option<String>,
}

impl Default for TransformOptions {
    fn default() -> Self {
        Self {
            width: None,
            height: None,
            fit: None,
            quality: None,
            preset: None,
        }
    }
}

pub fn build_url(username: &str, path: &str, opts: Option<&TransformOptions>) -> String {
    let base = format!("https://img-src.io/i/{}/{}", username, path);

    let opts = match opts {
        Some(o) => o,
        None => return base,
    };

    // Presets use p:name syntax in the URL
    if let Some(preset) = &opts.preset {
        return format!("{}?p:{}", base, preset);
    }

    let mut params = Vec::new();
    if let Some(w) = opts.width {
        params.push(format!("w={}", w));
    }
    if let Some(h) = opts.height {
        params.push(format!("h={}", h));
    }
    if let Some(fit) = &opts.fit {
        params.push(format!("fit={}", fit));
    }
    if let Some(q) = opts.quality {
        params.push(format!("q={}", q));
    }
    // Note: Output format is determined by file extension in the path, not a query parameter

    if params.is_empty() {
        base
    } else {
        format!("{}?{}", base, params.join("&"))
    }
}

// Usage
fn main() {
    let url = build_url("john", "photo.jpg", Some(&TransformOptions {
        width: Some(800),
        height: Some(600),
        fit: Some("cover".into()),
        quality: Some(85),
        ..Default::default()
    }));
    // https://img-src.io/i/john/photo.jpg?w=800&h=600&fit=cover&q=85
}
```

## Axum Web Framework

```rust
use axum::{
    extract::{Multipart, State},
    response::Json,
    routing::{get, post},
    Router,
};
use img_src::apis::{configuration::Configuration, images_api};
use serde_json::{json, Value};
use std::sync::Arc;

struct AppState {
    config: Configuration,
}

async fn upload(
    State(state): State<Arc<AppState>>,
    mut multipart: Multipart,
) -> Json<Value> {
    while let Some(field) = multipart.next_field().await.unwrap() {
        let name = field.name().unwrap_or("").to_string();
        if name != "file" {
            continue;
        }

        let filename = field.file_name().unwrap_or("upload").to_string();
        let data = field.bytes().await.unwrap();

        // Write to temp file for upload
        let temp_path = std::env::temp_dir().join(&filename);
        tokio::fs::write(&temp_path, &data).await.unwrap();

        match images_api::upload_image(
            &state.config,
            Some(temp_path.clone()),
            Some(&format!("uploads/{}", filename)),
            None,
        ).await {
            Ok(res) => {
                let _ = tokio::fs::remove_file(&temp_path).await;
                return Json(json!({ "url": res.url }));
            }
            Err(e) => {
                let _ = tokio::fs::remove_file(&temp_path).await;
                return Json(json!({ "error": e.to_string() }));
            }
        }
    }

    Json(json!({ "error": "No file provided" }))
}

async fn list_images(State(state): State<Arc<AppState>>) -> Json<Value> {
    match images_api::list_images(&state.config, Some(20), None, None).await {
        Ok(res) => Json(json!({
            "images": res.images,
            "total": res.total
        })),
        Err(e) => Json(json!({ "error": e.to_string() })),
    }
}

#[tokio::main]
async fn main() {
    let mut config = Configuration::new();
    config.bearer_access_token = Some(
        std::env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
    );

    let state = Arc::new(AppState { config });

    let app = Router::new()
        .route("/upload", post(upload))
        .route("/images", get(list_images))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    println!("Listening on http://0.0.0.0:3000");
    axum::serve(listener, app).await.unwrap();
}
```

## Actix-web Framework

```rust
use actix_multipart::Multipart;
use actix_web::{web, App, HttpResponse, HttpServer};
use futures_util::StreamExt;
use img_src::apis::{configuration::Configuration, images_api};
use std::sync::Arc;

struct AppState {
    config: Configuration,
}

async fn upload(
    state: web::Data<Arc<AppState>>,
    mut payload: Multipart,
) -> HttpResponse {
    let mut data = Vec::new();
    let mut filename = String::from("upload");

    while let Some(Ok(mut field)) = payload.next().await {
        if let Some(name) = field.content_disposition().get_filename() {
            filename = name.to_string();
        }

        while let Some(Ok(chunk)) = field.next().await {
            data.extend_from_slice(&chunk);
        }
    }

    if data.is_empty() {
        return HttpResponse::BadRequest().json(serde_json::json!({
            "error": "No file provided"
        }));
    }

    // Write to temp file for upload
    let temp_path = std::env::temp_dir().join(&filename);
    if let Err(e) = tokio::fs::write(&temp_path, &data).await {
        return HttpResponse::InternalServerError().json(serde_json::json!({
            "error": e.to_string()
        }));
    }

    match images_api::upload_image(
        &state.config,
        Some(temp_path.clone()),
        Some(&format!("uploads/{}", filename)),
        None,
    ).await {
        Ok(res) => {
            let _ = tokio::fs::remove_file(&temp_path).await;
            HttpResponse::Ok().json(serde_json::json!({ "url": res.url }))
        }
        Err(e) => {
            let _ = tokio::fs::remove_file(&temp_path).await;
            HttpResponse::InternalServerError().json(serde_json::json!({
                "error": e.to_string()
            }))
        }
    }
}

async fn list_images(state: web::Data<Arc<AppState>>) -> HttpResponse {
    match images_api::list_images(&state.config, Some(20), None, None).await {
        Ok(res) => HttpResponse::Ok().json(serde_json::json!({
            "images": res.images,
            "total": res.total
        })),
        Err(e) => HttpResponse::InternalServerError().json(serde_json::json!({
            "error": e.to_string()
        })),
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let mut config = Configuration::new();
    config.bearer_access_token = Some(
        std::env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
    );

    let state = web::Data::new(Arc::new(AppState { config }));

    HttpServer::new(move || {
        App::new()
            .app_data(state.clone())
            .route("/upload", web::post().to(upload))
            .route("/images", web::get().to(list_images))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}
```

## Concurrent Uploads

Upload multiple images concurrently using tokio:

```rust
use img_src::apis::{configuration::Configuration, images_api, Error};
use std::path::PathBuf;
use std::sync::Arc;

async fn upload_images(
    config: Arc<Configuration>,
    paths: Vec<PathBuf>,
) -> Vec<Result<String, String>> {
    let handles: Vec<_> = paths
        .into_iter()
        .map(|path| {
            let config = config.clone();
            tokio::spawn(async move {
                let filename = path.file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("upload");

                match images_api::upload_image(
                    &config,
                    Some(path),
                    Some(&format!("batch/{}", filename)),
                    None,
                ).await {
                    Ok(res) => Ok(res.url),
                    Err(e) => Err(e.to_string()),
                }
            })
        })
        .collect();

    let mut results = Vec::new();
    for handle in handles {
        match handle.await {
            Ok(result) => results.push(result),
            Err(e) => results.push(Err(e.to_string())),
        }
    }
    results
}

#[tokio::main]
async fn main() {
    let mut config = Configuration::new();
    config.bearer_access_token = Some(
        std::env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
    );
    let config = Arc::new(config);

    let paths = vec![
        PathBuf::from("photo1.jpg"),
        PathBuf::from("photo2.jpg"),
        PathBuf::from("photo3.jpg"),
    ];

    let results = upload_images(config, paths).await;

    for result in results {
        match result {
            Ok(url) => println!("Uploaded: {}", url),
            Err(e) => eprintln!("Error: {}", e),
        }
    }
}
```

## Image Processing Pipeline

Combine img-src with local image processing:

```rust
use image::{DynamicImage, ImageFormat};
use img_src::apis::{configuration::Configuration, images_api};
use std::io::Cursor;
use std::path::PathBuf;

async fn process_and_upload(
    config: &Configuration,
    img: DynamicImage,
    path: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    // Apply local processing (e.g., watermark, filter)
    let processed = img.grayscale();

    // Encode to bytes and write to temp file
    let mut bytes = Vec::new();
    processed.write_to(&mut Cursor::new(&mut bytes), ImageFormat::Jpeg)?;

    let temp_path = std::env::temp_dir().join("processed.jpg");
    tokio::fs::write(&temp_path, &bytes).await?;

    // Upload to img-src
    let res = images_api::upload_image(
        config,
        Some(temp_path.clone()),
        Some(path),
        None,
    ).await?;

    let _ = tokio::fs::remove_file(&temp_path).await;

    Ok(res.url)
}
```

## CLI Tool Example

Create a CLI tool for uploading images:

```rust
use clap::Parser;
use img_src::apis::{configuration::Configuration, images_api};
use std::path::PathBuf;

#[derive(Parser)]
#[command(name = "imgsrc-upload")]
#[command(about = "Upload images to img-src")]
struct Cli {
    /// Files to upload
    #[arg(required = true)]
    files: Vec<PathBuf>,

    /// Destination path prefix
    #[arg(short, long, default_value = "uploads")]
    prefix: String,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let cli = Cli::parse();

    let mut config = Configuration::new();
    config.bearer_access_token = Some(
        std::env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
    );

    for file in cli.files {
        let filename = file.file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("upload");

        let path = format!("{}/{}", cli.prefix, filename);

        print!("Uploading {}...", filename);

        match images_api::upload_image(
            &config,
            Some(file),
            Some(&path),
            None,
        ).await {
            Ok(res) => println!(" done: {}", res.url),
            Err(e) => println!(" error: {}", e),
        }
    }

    Ok(())
}
```

## Error Handling

```rust
use img_src::apis::{images_api, Error};

async fn handle_errors(config: &img_src::apis::configuration::Configuration) {
    match images_api::get_image(config, "nonexistent").await {
        Ok(res) => println!("Found: {:?}", res.metadata),
        Err(Error::ResponseError(resp)) => {
            println!("HTTP {}: {}", resp.status, resp.content);
        }
        Err(Error::Reqwest(e)) => {
            println!("Network error: {}", e);
        }
        Err(Error::Serde(e)) => {
            println!("Parse error: {}", e);
        }
        Err(Error::Io(e)) => {
            println!("IO error: {}", e);
        }
    }
}
```

## Tera Template Integration

```rust
use tera::{Context, Tera};

fn render_gallery(username: &str, images: &[&str]) -> String {
    let mut tera = Tera::default();
    tera.add_raw_template("gallery", r#"
<!DOCTYPE html>
<html>
<head><title>Gallery</title></head>
<body>
    <div class="gallery">
        {% for path in images %}
        <img src="https://img-src.io/i/{{ username }}/{{ path }}?w=300&h=300&fit=cover"
             alt="{{ path }}" loading="lazy">
        {% endfor %}
    </div>
</body>
</html>
    "#).unwrap();

    let mut context = Context::new();
    context.insert("username", username);
    context.insert("images", images);

    tera.render("gallery", &context).unwrap()
}
```
