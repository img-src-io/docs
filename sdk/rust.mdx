---
title: Rust SDK
description: "Official Rust SDK for img-src"
---

# Rust SDK

The official Rust SDK for img-src provides a type-safe, async-first interface to the API.

<Info>
  **Crate:** `img_src` | **Edition:** 2021 | [crates.io](https://crates.io/crates/img_src) | [GitHub](https://github.com/img-src-io/sdk-rust)
</Info>

## Installation

Add to your `Cargo.toml`:

```toml
[dependencies]
img_src = "0.2"
tokio = { version = "1", features = ["full"] }
```

## Quick Start

```rust
use img_src::apis::{configuration::Configuration, images_api};
use std::path::PathBuf;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut config = Configuration::new();
    config.bearer_access_token = Some("imgsrc_YOUR_API_KEY".to_string());

    // Upload an image
    let res = images_api::upload_image(
        &config,
        Some(PathBuf::from("photo.jpg")),
        Some("photos/vacation.jpg"),
        None,
    ).await?;

    println!("{}", res.url);
    // https://img-src.io/i/username/photos/vacation.jpg

    Ok(())
}
```

## Configuration

```rust
use img_src::apis::configuration::Configuration;

let mut config = Configuration::new();

// Required
config.bearer_access_token = Some("imgsrc_YOUR_API_KEY".to_string());

// Optional
config.base_path = "https://api.img-src.io".to_string(); // Default
```

### Environment Variables

```rust
use img_src::apis::configuration::Configuration;
use std::env;

let mut config = Configuration::new();
config.bearer_access_token = Some(
    env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
);
```

## Images

### Upload

```rust
use img_src::apis::{configuration::Configuration, images_api};
use std::path::PathBuf;

// From file path
let res = images_api::upload_image(
    &config,
    Some(PathBuf::from("photo.jpg")),
    Some("photos/vacation.jpg"),
    None,
).await?;

// With visibility (Pro)
let res = images_api::upload_image(
    &config,
    Some(PathBuf::from("photo.jpg")),
    Some("photos/private.jpg"),
    Some("private"),
).await?;
```

### List

```rust
use img_src::apis::images_api;

// List all images (default limit: 50)
let res = images_api::list_images(&config, None, None, None).await?;
for image in &res.images {
    println!("{}", image.url);
}

// With pagination
let res = images_api::list_images(&config, Some(20), Some(40), None).await?;

// Filter by path prefix
let res = images_api::list_images(&config, Some(50), None, Some("photos/")).await?;
```

### Search

```rust
let res = images_api::search_images(&config, "vacation", Some(10)).await?;
for result in &res.results {
    println!("{:?}", result.paths);
}
```

### Get

```rust
let res = images_api::get_image(&config, "img_abc123").await?;
println!("Dimensions: {:?}x{:?}", res.metadata.width, res.metadata.height);
```

### Delete

```rust
images_api::delete_image(&config, "img_abc123").await?;
```

### Create Signed URL (Pro)

```rust
use img_src::models::CreateSignedUrlRequest;

let req = CreateSignedUrlRequest {
    expires_in_seconds: Some(3600), // 1 hour (default)
    transformation: None,
};

let res = images_api::create_signed_url(&config, "img_abc123", Some(req)).await?;
println!("{}", res.signed_url);
```

### Update Visibility (Pro)

```rust
use img_src::models::UpdateVisibilityRequest;

let req = UpdateVisibilityRequest {
    visibility: "private".to_string(),
};

images_api::update_visibility(&config, "img_abc123", req).await?;
```

### Delete Image Path

```rust
let res = images_api::delete_image_path(&config, "username", "photos/old-photo.jpg").await?;
println!("Image deleted: {}", res.image_deleted);
```

## Settings

```rust
use img_src::apis::settings_api;
use img_src::models::UpdateSettingsRequest;

// Get settings
let res = settings_api::get_settings(&config).await?;
println!("Quality: {}", res.settings.default_quality);

// Update settings
let req = UpdateSettingsRequest {
    default_quality: Some(85),
    default_fit_mode: Some("cover".to_string()),
    delivery_formats: Some(vec!["webp".to_string(), "jpeg".to_string()]),
    ..Default::default()
};

settings_api::update_settings(&config, Some(req)).await?;
```

## Presets (Pro)

```rust
use img_src::apis::presets_api;
use img_src::models::{CreatePresetRequest, UpdatePresetRequest};
use std::collections::HashMap;

// List presets
let res = presets_api::list_presets(&config).await?;

// Create preset
let mut params = HashMap::new();
params.insert("w".to_string(), serde_json::json!(200));
params.insert("h".to_string(), serde_json::json!(200));
params.insert("fit".to_string(), serde_json::json!("cover"));

let preset = presets_api::create_preset(&config, Some(CreatePresetRequest::new(
    "thumbnail".to_string(),
    params,
))).await?;

// Get preset
let preset = presets_api::get_preset(&config, "preset_id").await?;

// Update preset
let mut new_params = HashMap::new();
new_params.insert("w".to_string(), serde_json::json!(250));
new_params.insert("h".to_string(), serde_json::json!(250));
new_params.insert("fit".to_string(), serde_json::json!("cover"));

presets_api::update_preset(&config, "preset_id", Some(UpdatePresetRequest {
    params: Some(new_params),
    ..Default::default()
})).await?;

// Delete preset
presets_api::delete_preset(&config, "thumbnail").await?;
```

## Usage

```rust
use img_src::apis::usage_api;

let res = usage_api::get_usage(&config).await?;

println!("Plan: {}", res.plan_name);
println!("Storage: {} MB", res.storage_used_mb);
println!("Uploads this period: {}", res.current_period.uploads);
```

## Error Handling

Each API function returns `Result<T, Error<E>>` where `E` is a per-operation error enum:

```rust
use img_src::apis::{images_api, Error};

match images_api::get_image(&config, "nonexistent").await {
    Ok(res) => println!("Found: {:?}", res.metadata),
    Err(Error::ResponseError(resp)) => {
        println!("HTTP {}: {}", resp.status, resp.content);
    }
    Err(Error::Reqwest(e)) => {
        println!("Network error: {}", e);
    }
    Err(Error::Serde(e)) => {
        println!("Parse error: {}", e);
    }
    Err(Error::Io(e)) => {
        println!("IO error: {}", e);
    }
}
```

## TLS Features

The SDK supports two TLS backends:

```toml
# Default - uses system native TLS
[dependencies]
img_src = "0.2"

# Use rustls instead (no system OpenSSL dependency)
[dependencies]
img_src = { version = "0.2", default-features = false, features = ["rustls-tls"] }
```

## Types

All model types are in the `models` module:

```rust
use img_src::models::{
    UploadResponse,
    MetadataResponse,
    ImageListResponse,
    SearchResponse,
    SignedUrlResponse,
    UpdateVisibilityRequest,
    UpdateVisibilityResponse,
    PathDeleteResponse,
    SettingsResponse,
    UpdateSettingsRequest,
    Preset,
    CreatePresetRequest,
    UpdatePresetRequest,
    UsageResponse,
    DeleteResponse,
};
```

## Axum Example

```rust
use axum::{
    extract::{Multipart, State},
    response::Json,
    routing::{get, post},
    Router,
};
use img_src::apis::{configuration::Configuration, images_api};
use serde_json::{json, Value};
use std::sync::Arc;

struct AppState {
    config: Configuration,
}

async fn upload(
    State(state): State<Arc<AppState>>,
    mut multipart: Multipart,
) -> Json<Value> {
    while let Some(field) = multipart.next_field().await.unwrap() {
        if field.name() == Some("file") {
            let filename = field.file_name().unwrap_or("upload").to_string();
            let data = field.bytes().await.unwrap();

            // Write to a temp file for upload
            let temp_path = std::env::temp_dir().join(&filename);
            tokio::fs::write(&temp_path, &data).await.unwrap();

            match images_api::upload_image(
                &state.config,
                Some(temp_path.clone()),
                Some(&format!("uploads/{}", filename)),
                None,
            ).await {
                Ok(res) => {
                    let _ = tokio::fs::remove_file(&temp_path).await;
                    return Json(json!({ "url": res.url }));
                }
                Err(e) => {
                    let _ = tokio::fs::remove_file(&temp_path).await;
                    return Json(json!({ "error": e.to_string() }));
                }
            }
        }
    }

    Json(json!({ "error": "No file provided" }))
}

async fn list_images(State(state): State<Arc<AppState>>) -> Json<Value> {
    match images_api::list_images(&state.config, Some(20), None, None).await {
        Ok(res) => Json(json!({
            "images": res.images,
            "total": res.total
        })),
        Err(e) => Json(json!({ "error": e.to_string() })),
    }
}

#[tokio::main]
async fn main() {
    let mut config = Configuration::new();
    config.bearer_access_token = Some(
        std::env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
    );

    let state = Arc::new(AppState { config });

    let app = Router::new()
        .route("/upload", post(upload))
        .route("/images", get(list_images))
        .with_state(state);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await.unwrap();
    println!("Listening on http://0.0.0.0:3000");
    axum::serve(listener, app).await.unwrap();
}
```

## Actix-web Example

```rust
use actix_multipart::Multipart;
use actix_web::{web, App, HttpResponse, HttpServer};
use futures_util::StreamExt;
use img_src::apis::{configuration::Configuration, images_api};
use std::sync::Arc;

struct AppState {
    config: Configuration,
}

async fn upload(
    state: web::Data<Arc<AppState>>,
    mut payload: Multipart,
) -> HttpResponse {
    let mut data = Vec::new();
    let mut filename = String::from("upload");

    while let Some(Ok(mut field)) = payload.next().await {
        if let Some(name) = field.content_disposition().get_filename() {
            filename = name.to_string();
        }

        while let Some(Ok(chunk)) = field.next().await {
            data.extend_from_slice(&chunk);
        }
    }

    if data.is_empty() {
        return HttpResponse::BadRequest().json(serde_json::json!({
            "error": "No file provided"
        }));
    }

    // Write to temp file for upload
    let temp_path = std::env::temp_dir().join(&filename);
    if let Err(e) = tokio::fs::write(&temp_path, &data).await {
        return HttpResponse::InternalServerError().json(serde_json::json!({
            "error": e.to_string()
        }));
    }

    match images_api::upload_image(
        &state.config,
        Some(temp_path.clone()),
        Some(&format!("uploads/{}", filename)),
        None,
    ).await {
        Ok(res) => {
            let _ = tokio::fs::remove_file(&temp_path).await;
            HttpResponse::Ok().json(serde_json::json!({ "url": res.url }))
        }
        Err(e) => {
            let _ = tokio::fs::remove_file(&temp_path).await;
            HttpResponse::InternalServerError().json(serde_json::json!({
                "error": e.to_string()
            }))
        }
    }
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    let mut config = Configuration::new();
    config.bearer_access_token = Some(
        std::env::var("IMGSRC_API_KEY").expect("IMGSRC_API_KEY not set")
    );

    let state = web::Data::new(Arc::new(AppState { config }));

    HttpServer::new(move || {
        App::new()
            .app_data(state.clone())
            .route("/upload", web::post().to(upload))
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await
}
```

## Related

- [API Reference](/api-reference/overview) - Full API documentation
- [Image Transformation Guide](/guides/image-transformation) - Transformation parameters
- [Rust Integration Examples](/examples/rust) - More Rust examples with Axum, Actix-web, and CLI
